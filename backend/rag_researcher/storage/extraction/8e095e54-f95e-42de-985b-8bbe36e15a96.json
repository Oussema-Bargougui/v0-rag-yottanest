{
  "doc_id": "8e095e54-f95e-42de-985b-8bbe36e15a96",
  "filename": "ai_teacher.pdf",
  "file_size": 526414,
  "file_hash": "0cb6b6db39703510e7a6f5ee60d4e316c18a7dc623f014bb201a3e117ad385cf",
  "ingestion_timestamp": "2026-01-26T21:50:25.268650",
  "processing_duration": 0.144067,
  "extraction_version": "5.0.0",
  "pages": [
    {
      "page_number": 1,
      "text": "Classroom_control_agent :\nfrom mentor_ai.core.state import TeacherState\n\nclass ClassroomControlAgent:\n@staticmethod def build_redirect_message(state: TeacherState) -> str:\nsteps = state[\"lesson_steps\"] step = steps[state[\"current_step_index\"]] if steps else None objective = step[\"objective\"] if step else \"the current objective\" return ( \"Stay focused.\\n\" f\"We are working on: {objective}.\\n\" \"Answer the check question or ask a question about this step.\" )\n\nfrom typing import List\n\nfrom mentor_ai.core.state import Curriculum, LessonStep\n\nclass CurriculumAgent:\n@staticmethod def build_steps(curriculum: Curriculum) -> List[LessonStep]:\nchapter = curriculum[\"chapter\"].strip().lower() lesson = curriculum[\"lesson\"].strip().lower()\n\nif chapter == \"mathematics\" and lesson == \"fractions\":\nreturn [ { \"step_id\": 0, \"objective\": \"Explain what a fraction represents as parts of a whole\", \"strategy_pool\": [\"concrete_example\", \"visual\", \"analogy\", \"step_by_step\"], \"check_type\": \"question\", }, { \"step_id\": 1, \"objective\": \"Define numerator as how many parts are taken\", \"strategy_pool\": [\"visual\", \"step_by_step\", \"concrete_example\", \"analogy\"],",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 2,
      "text": "\"check_type\": \"question\", }, { \"step_id\": 2, \"objective\": \"Define denominator as how many equal parts make the whole\", \"strategy_pool\": [\"visual\", \"concrete_example\", \"step_by_step\", \"analogy\"], \"check_type\": \"question\", }, { \"step_id\": 3, \"objective\": \"Identify numerator and denominator in simple fractions like 3/5\", \"strategy_pool\": [\"step_by_step\", \"visual\", \"concrete_example\"], \"check_type\": \"exercise\", }, { \"step_id\": 4, \"objective\": \"Interpret a fraction as 'numerator out of denominator' parts\", \"strategy_pool\": [\"analogy\", \"step_by_step\", \"concrete_example\", \"visual\"], \"check_type\": \"explanation_request\", }, ]\n\nreturn [ { \"step_id\": 0, \"objective\": f\"Define the core idea of {curriculum['lesson']}\", \"strategy_pool\": [\"step_by_step\", \"concrete_example\", \"visual\", \"analogy\"], \"check_type\": \"question\", }, { \"step_id\": 1, \"objective\": \"Practice identifying the key parts of the concept\", \"strategy_pool\": [\"step_by_step\", \"concrete_example\", \"visual\"], \"check_type\": \"exercise\", },",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 3,
      "text": "]\n\nfrom typing import Any, Dict\n\nfrom mentor_ai.core.state import TeacherState\n\nclass MemoryAgent:\n@staticmethod def update(state: TeacherState) -> TeacherState:\nanalysis = state.get(\"last_analysis\") decision = state.get(\"last_decision\") steps = state[\"lesson_steps\"] if not steps:\nreturn state\n\nanalysis_step_id = None if isinstance(analysis, dict):\nanalysis_step_id = analysis.get(\"step_id\") step = next((s for s in steps if s[\"step_id\"] == analysis_step_id), None) if analysis_step_id is not None else None if step is None:\nstep = steps[state[\"current_step_index\"]] memory = state[\"memory\"]\n\nif decision:\nmemory[\"last_strategy_by_step\"][step[\"step_id\"]] = str(decision.get(\"strategy\") or \"\") memory[\"last_action_by_step\"][step[\"step_id\"]] = str(decision.get(\"action\") or \"\")\n\nif not analysis:\nstate[\"pedagogy\"][\"mastery_level\"] = MemoryAgent._compute_overall_mastery(state) return state\n\nemotion = str(analysis.get(\"emotion\") or \"neutral\").lower() memory[\"emotional_patterns\"][emotion] = memory[\"emotional_patterns\"].get(emotion, 0) + 1",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 4,
      "text": "confusion_type = str(analysis.get(\"confusion_type\") or \"none\").lower() if confusion_type != \"none\":\nmemory[\"confusion_patterns\"][confusion_type] = memory[\"confusion_patterns\"].get(confusion_type, 0) + 1\n\nunderstanding = str(analysis.get(\"understanding_level\") or \"none\").lower() current = memory[\"step_mastery\"].get(step[\"step_id\"], 0)\n\nif understanding == \"strong\":\nupdated = min(100, current + 40) elif understanding == \"good\":\nupdated = min(100, current + 25) elif understanding == \"partial\":\nupdated = max(0, current - 5) memory[\"failed_steps\"][step[\"step_id\"]] = memory[\"failed_steps\"].get(step[\"step_id\"], 0) + 1 else:\nupdated = max(0, current - 10) memory[\"failed_steps\"][step[\"step_id\"]] = memory[\"failed_steps\"].get(step[\"step_id\"], 0) + 1\n\nmemory[\"step_mastery\"][step[\"step_id\"]] = updated\n\nthreshold = state[\"pedagogy\"][\"mastery_threshold\"] if updated >= threshold and step[\"step_id\"] not in memory[\"success_steps\"]:\nmemory[\"success_steps\"].append(step[\"step_id\"])\n\nstrategy = str((decision or {}).get(\"strategy\") or \"\").strip() if strategy and updated >= threshold and strategy not in memory[\"preferred_strategies\"]:\nmemory[\"preferred_strategies\"].append(strategy)\n\nstate[\"pedagogy\"][\"mastery_level\"] = MemoryAgent._compute_overall_mastery(state) return state\n\n@staticmethod def _compute_overall_mastery(state: TeacherState) -> int:\nsteps = state[\"lesson_steps\"] mastery = state[\"memory\"][\"step_mastery\"] if not steps:",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 5,
      "text": "return 0 values = [mastery.get(s[\"step_id\"], 0) for s in steps] return int(sum(values) / len(values))\n\nfrom typing import Any, Dict, Optional\n\nfrom mentor_ai.core.enums import DirectorAction, UnderstandingLevel from mentor_ai.core.state import TeacherState\n\nclass PedagogicalDirectorAgent:\n@staticmethod def decide(state: TeacherState) -> Dict[str, Any]:\nsteps = state[\"lesson_steps\"] step_index = state[\"current_step_index\"] analysis = state.get(\"last_analysis\") memory = state[\"memory\"]\n\nif not steps:\nreturn { \"action\": DirectorAction.EXPLAIN.value, \"target_step_index\": 0, \"strategy\": \"step_by_step\", \"check_type\": \"question\", \"reason\": \"No lesson steps loaded yet.\", }\n\nstep = steps[min(step_index, len(steps) - 1)] target_step_index = min(step_index, len(steps) - 1) step_mastery = memory[\"step_mastery\"].get(step[\"step_id\"], 0) threshold = state[\"pedagogy\"][\"mastery_threshold\"] last_strategy = memory[\"last_strategy_by_step\"].get(step[\"step_id\"])\n\nif analysis is None:\nstrategy = PedagogicalDirectorAgent._pick_strategy(step, last_strategy=last_strategy) return { \"action\": DirectorAction.EXPLAIN.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"],",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 6,
      "text": "\"reason\": \"Start teaching the current step.\", }\n\nif analysis.get(\"off_topic\") is True:\nreturn { \"action\": DirectorAction.CONTROL.value, \"target_step_index\": target_step_index, \"strategy\": \"authority_redirect\", \"check_type\": \"question\", \"reason\": \"Student is off-topic; redirect to the current objective.\", }\n\nunderstanding = str(analysis.get(\"understanding_level\") or UnderstandingLevel.NONE.value).lower() failed_count = memory[\"failed_steps\"].get(step[\"step_id\"], 0) strategy = PedagogicalDirectorAgent._pick_strategy(step, last_strategy=last_strategy, failed_count=failed_count)\n\nif understanding in (UnderstandingLevel.GOOD.value, UnderstandingLevel.STRONG.value):\nif step_mastery >= threshold and understanding == UnderstandingLevel.STRONG.value:\nif step_index >= len(steps) - 1:\nreturn { \"action\": DirectorAction.COMPLETE.value, \"target_step_index\": target_step_index, \"strategy\": \"summary\", \"check_type\": \"question\", \"reason\": \"Final step mastered; complete the lesson.\", } return { \"action\": DirectorAction.MOVE_ON.value, \"target_step_index\": target_step_index + 1, \"strategy\": \"progression\", \"check_type\": steps[target_step_index + 1][\"check_type\"], \"reason\": \"Current step mastered; move to the next step.\", }\n\nreturn { \"action\": DirectorAction.ASK_QUESTION.value, \"target_step_index\": target_step_index,",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 7,
      "text": "\"strategy\": \"checking\", \"check_type\": step[\"check_type\"], \"reason\": \"Understanding looks good; verify mastery with a focused check.\", }\n\nif understanding == UnderstandingLevel.PARTIAL.value:\nif failed_count >= 1:\nreturn { \"action\": DirectorAction.REMEDIATE.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"Partial understanding with prior failure; remediate using a different representation.\", } return { \"action\": DirectorAction.REPHRASE.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"Partial understanding; rephrase using a different strategy.\", }\n\nif failed_count >= 1:\nreturn { \"action\": DirectorAction.REMEDIATE.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"No understanding with prior failure; apply remediation.\", }\n\nreturn { \"action\": DirectorAction.EXPLAIN.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"No understanding; explain again with a different strategy.\",",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 8,
      "text": "}\n\n@staticmethod def _pick_strategy(step: Dict[str, Any], *, last_strategy: Optional[str], failed_count: int = 0) -> str:\npool = list(step.get(\"strategy_pool\") or []) if not pool:\nreturn \"step_by_step\"\n\nif last_strategy and last_strategy in pool:\npool = [s for s in pool if s != last_strategy] or [last_strategy]\n\nif failed_count >= 2:\nif \"concrete_example\" in pool:\nreturn \"concrete_example\" if \"visual\" in pool:\nreturn \"visual\"\n\nreturn pool[0]\n\nimport json from typing import Any, Dict\n\nfrom mentor_ai.core.state import TeacherState from mentor_ai.services.llm_service import LLMService\n\nclass StudentUnderstandingAgent:\n@staticmethod def analyze(state: TeacherState) -> Dict[str, Any]:\nstudent_input = (state.get(\"last_student_input\") or \"\").strip() step = state[\"lesson_steps\"][state[\"current_step_index\"]] if state[\"lesson_steps\"] else None\n\nsystem = ( \"You are StudentUnderstandingAgent.\\n\" \"You analyze the student's input for understanding.\\n\" \"You do not teach.\\n\" \"You do not decide pedagogy.\\n\" \"Return strict JSON only.\\n\\n\"",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 9,
      "text": "\"Output JSON schema:\\n\" \"{\\n\" ' \"understanding_level\": \"none|partial|good|strong\",\\n' ' \"confusion_type\": \"conceptual|procedural|vocabulary|none\",\\n' ' \"emotion\": \"frustrated|confident|neutral|bored\",\\n' ' \"off_topic\": true|false,\\n' ' \"guessing\": true|false,\\n' ' \"hesitation\": true|false,\\n' ' \"notes\": \"string\"\\n' \"}\\n\" )\n\ncontext = { \"chapter\": state[\"curriculum\"][\"chapter\"], \"lesson\": state[\"curriculum\"][\"lesson\"], \"competence\": state[\"curriculum\"][\"competence\"], \"current_step_index\": state[\"current_step_index\"], \"current_step_objective\": step[\"objective\"] if step else None, \"student_input\": student_input, }\n\nuser = \"Analyze the student input.\\n\\nContext:\\n\" + json.dumps(context) content = LLMService.chat( [ {\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\": user}, ], temperature=0.0, json_mode=True, ) result = json.loads(content) if step is not None:\nresult[\"step_id\"] = step[\"step_id\"] result[\"step_index\"] = state[\"current_step_index\"] return result\n\nimport json from typing import Any, Dict\n\nfrom mentor_ai.core.state import TeacherState",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 10,
      "text": "from mentor_ai.services.llm_service import LLMService\n\nclass TeacherAgent:\n@staticmethod def speak(state: TeacherState) -> str:\ndecision = state.get(\"last_decision\") or {} steps = state[\"lesson_steps\"] step = steps[state[\"current_step_index\"]] if steps else None\n\nexecute = decision.get(\"execute\") or {} teacher_action = execute.get(\"teacher_action\") or decision.get(\"action\") teacher_strategy = execute.get(\"teacher_strategy\") or decision.get(\"strategy\") check_type = execute.get(\"check_type\") or decision.get(\"check_type\")\n\ndirective: Dict[str, Any] = { \"action\": teacher_action, \"strategy\": teacher_strategy, \"check_type\": check_type, \"objective\": step[\"objective\"] if step else None, \"student_name\": state[\"student\"].get(\"name\"), \"student_mood\": state[\"student\"].get(\"mood\"), \"learning_style\": state[\"student\"].get(\"learning_style\"), \"mastery_level\": state[\"pedagogy\"][\"mastery_level\"], \"step_index\": state[\"current_step_index\"], }\n\nsystem = ( \"You are TeacherAgent.\\n\" \"You are the voice only.\\n\" \"You do not decide pedagogy.\\n\" \"You follow the directive.\\n\" \"No free conversation.\\n\" \"No small talk.\\n\" \"Do not invent new goals.\\n\" \"Prioritize teaching rituals: framing, pacing, reassurance, and progression.\\n\" )\n\nuser = ( \"Generate the teacher message for the student.\\n\"",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 11,
      "text": "\"Constraints:\\n\" \"- One objective at a time.\\n\" \"- If action is ASK_QUESTION or TEST, end with a single clear prompt.\\n\" \"- If action is EXPLAIN or REPHRASE, explain and then ask a focused check.\\n\" \"- Avoid repeated metaphors.\\n\" \"- Keep authority and clarity.\\n\\n\" \"Directive:\\n\" + json.dumps(directive) )\n\nreturn LLMService.chat( [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\":\nuser}], temperature=0.4, json_mode=False, )\n\n@staticmethod def remediate(state: TeacherState) -> str:\ndecision = state.get(\"last_decision\") or {} steps = state[\"lesson_steps\"] step = steps[state[\"current_step_index\"]] if steps else None analysis = state.get(\"last_analysis\") or {}\n\nexecute = decision.get(\"execute\") or {} teacher_strategy = execute.get(\"teacher_strategy\") or decision.get(\"strategy\")\n\ndirective: Dict[str, Any] = { \"action\": \"REMEDIATE\", \"strategy\": teacher_strategy, \"objective\": step[\"objective\"] if step else None, \"confusion_type\": analysis.get(\"confusion_type\"), \"emotion\": analysis.get(\"emotion\"), \"step_index\": state[\"current_step_index\"], }\n\nsystem = ( \"You are TeacherAgent.\\n\" \"You are executing a remediation intervention.\\n\"",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 12,
      "text": "\"No free conversation.\\n\" \"No generic praise.\\n\" \"Use pacing and reassurance.\\n\" \"Change representation.\\n\" \"Keep it short and targeted.\\n\" )\n\nuser = \"Generate the remediation message.\\n\\nDirective:\\n\" + json.dumps(directive) return LLMService.chat( [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\":\nuser}], temperature=0.3, json_mode=False, )\n\n@staticmethod def complete(state: TeacherState) -> str:\nsystem = ( \"You are TeacherAgent.\\n\" \"You close the lesson like a real teacher.\\n\" \"No small talk.\\n\" \"Summarize what was mastered.\\n\" \"Give one short next step.\\n\" ) user = ( \"Close the lesson.\\n\\nState summary:\\n\" + json.dumps( { \"chapter\": state[\"curriculum\"][\"chapter\"], \"lesson\": state[\"curriculum\"][\"lesson\"], \"competence\": state[\"curriculum\"][\"competence\"], \"mastery_level\": state[\"pedagogy\"][\"mastery_level\"], \"success_steps\": state[\"memory\"][\"success_steps\"], } ) ) return LLMService.chat( [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\":\nuser}], temperature=0.4, json_mode=False,",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 13,
      "text": ")\n\nfrom mentor_ai.agents.teacher_agent import TeacherAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef completion_node(state: TeacherState) -> TeacherState:\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.COMPLETED state[\"last_teacher_output\"] = TeacherAgent.complete(state) return state\n\nfrom mentor_ai.agents.curriculum_agent import CurriculumAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef curriculum_planning_node(state: TeacherState) -> TeacherState:\nsteps = CurriculumAgent.build_steps(state[\"curriculum\"]) state[\"lesson_steps\"] = steps state[\"current_step_index\"] = 0 state[\"last_analysis\"] = None state[\"last_decision\"] = None state[\"next_node\"] = None state[\"pedagogy\"][\"current_mode\"] = TeacherMode.TEACHING return state\n\nfrom mentor_ai.agents.memory_agent import MemoryAgent from mentor_ai.core.state import TeacherState\n\ndef memory_update_node(state: TeacherState) -> TeacherState:\nreturn MemoryAgent.update(state)",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 14,
      "text": "from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef onboarding_node(state: TeacherState) -> TeacherState:\nstudent = state[\"student\"] onboarding = state[\"onboarding\"] last_input = (state.get(\"last_student_input\") or \"\").strip()\n\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.ONBOARDING\n\nif onboarding[\"complete\"] is True:\nstate[\"last_teacher_output\"] = None return state\n\nstage = onboarding[\"stage\"]\n\nif stage == \"name\":\nif last_input:\nstudent[\"name\"] = last_input[:60] onboarding[\"stage\"] = \"mood\" state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"Before we start, tell me your name.\" return state\n\nif stage == \"mood\":\nif last_input:\nmood = last_input.lower() if \"frustr\" in mood:\nstudent[\"mood\"] = \"frustrated\" elif \"bored\" in mood:\nstudent[\"mood\"] = \"bored\" elif \"confident\" in mood:\nstudent[\"mood\"] = \"confident\" else:\nstudent[\"mood\"] = \"neutral\" onboarding[\"stage\"] = \"ready\" state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"How are you feeling about this topic right now: confident, neutral, frustrated, or bored?\" return state",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 15,
      "text": "if stage == \"ready\":\nif last_input:\nnormalized = last_input.lower() if any(k in normalized for k in [\"yes\", \"ready\", \"ok\", \"okay\", \"sure\", \"let's\", \"lets\", \"start\"]):\nonboarding[\"complete\"] = True onboarding[\"stage\"] = \"done\" state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"Good. We will start now. One step at a time.\" return state state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"Are you ready to start the lesson? Answer yes or no.\" return state\n\nonboarding[\"stage\"] = \"name\" state[\"last_teacher_output\"] = \"Before we start, tell me your name.\" return state\n\nfrom mentor_ai.agents.pedagogical_director_agent import PedagogicalDirectorAgent from mentor_ai.core.state import TeacherState\n\ndef pedagogical_decision_node(state: TeacherState) -> TeacherState:\nstate[\"last_decision\"] = PedagogicalDirectorAgent.decide(state) return state\n\nfrom mentor_ai.agents.teacher_agent import TeacherAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef remediation_node(state: TeacherState) -> TeacherState:\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.REMEDIATION state[\"last_teacher_output\"] = TeacherAgent.remediate(state) return state",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 16,
      "text": "from mentor_ai.core.state import TeacherState\n\ndef student_input_node(state: TeacherState) -> TeacherState:\nreturn state\n\nfrom mentor_ai.agents.classroom_control_agent import ClassroomControlAgent from mentor_ai.agents.teacher_agent import TeacherAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef teaching_node(state: TeacherState) -> TeacherState:\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.TEACHING decision = state.get(\"last_decision\") or {} execute = decision.get(\"execute\") or {} teacher_action = execute.get(\"teacher_action\") or decision.get(\"action\")\n\nif teacher_action == \"CONTROL\":\nstate[\"last_teacher_output\"] = ClassroomControlAgent.build_redirect_message(state) return state\n\nstate[\"last_teacher_output\"] = TeacherAgent.speak(state) return state\n\nfrom mentor_ai.core.enums import DirectorAction from mentor_ai.core.state import TeacherState\n\ndef transition_node(state: TeacherState) -> TeacherState:\ndecision = state.get(\"last_decision\") or {} action = str(decision.get(\"action\") or \"\") steps = state[\"lesson_steps\"]",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 17,
      "text": "if action == DirectorAction.COMPLETE.value:\ndecision[\"execute\"] = { \"node\": \"completion_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"COMPLETE\", \"teacher_strategy\": \"summary\", \"check_type\": \"question\", } state[\"next_node\"] = \"completion_node\" state[\"last_decision\"] = decision return state\n\nif action == DirectorAction.REMEDIATE.value:\ndecision[\"execute\"] = { \"node\": \"remediation_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"REMEDIATE\", \"teacher_strategy\": decision.get(\"strategy\"), \"check_type\": decision.get(\"check_type\"), } state[\"next_node\"] = \"remediation_node\" state[\"last_decision\"] = decision return state\n\nif action == DirectorAction.MOVE_ON.value:\ntarget = decision.get(\"target_step_index\") if isinstance(target, int):\nstate[\"current_step_index\"] = max(0, min(target, max(0, len(steps) - 1))) state[\"last_analysis\"] = None next_step = steps[state[\"current_step_index\"]] if steps else None strategy_pool = (next_step or {}).get(\"strategy_pool\") or [\"step_by_step\"] decision[\"execute\"] = { \"node\": \"teaching_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"EXPLAIN\", \"teacher_strategy\": strategy_pool[0], \"check_type\": (next_step or {}).get(\"check_type\") or \"question\", } state[\"next_node\"] = \"teaching_node\" state[\"last_decision\"] = decision",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 18,
      "text": "return state\n\nif action == DirectorAction.CONTROL.value:\ndecision[\"execute\"] = { \"node\": \"teaching_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"CONTROL\", \"teacher_strategy\": \"authority_redirect\", \"check_type\": \"question\", } state[\"next_node\"] = \"teaching_node\" state[\"last_decision\"] = decision return state\n\ndecision[\"execute\"] = { \"node\": \"teaching_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": action, \"teacher_strategy\": decision.get(\"strategy\"), \"check_type\": decision.get(\"check_type\"), } state[\"next_node\"] = \"teaching_node\" state[\"last_decision\"] = decision return state\n\nfrom mentor_ai.agents.student_understanding_agent import StudentUnderstandingAgent from mentor_ai.core.state import TeacherState\n\ndef understanding_analysis_node(state: TeacherState) -> TeacherState:\nstate[\"last_analysis\"] = StudentUnderstandingAgent.analyze(state) return state\n\nfrom langgraph.checkpoint.memory import MemorySaver from langgraph.graph import END, StateGraph",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 19,
      "text": "from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState from mentor_ai.graph.nodes.completion_node import completion_node from mentor_ai.graph.nodes.curriculum_planning_node import curriculum_planning_node from mentor_ai.graph.nodes.memory_update_node import memory_update_node from mentor_ai.graph.nodes.onboarding_node import onboarding_node from mentor_ai.graph.nodes.pedagogical_decision_node import pedagogical_decision_node from mentor_ai.graph.nodes.remediation_node import remediation_node from mentor_ai.graph.nodes.student_input_node import student_input_node from mentor_ai.graph.nodes.teaching_node import teaching_node from mentor_ai.graph.nodes.transition_node import transition_node from mentor_ai.graph.nodes.understanding_analysis_node import understanding_analysis_node\n\ndef _route_after_student_input(state: TeacherState) -> str:\nif state[\"pedagogy\"][\"current_mode\"] == TeacherMode.ONBOARDING:\nreturn \"onboarding_node\" return \"understanding_analysis_node\"\n\ndef _route_after_onboarding(state: TeacherState) -> str:\nif state[\"onboarding\"][\"complete\"] is True:\nreturn \"curriculum_planning_node\" return \"student_input_node\"\n\ndef _route_after_transition(state: TeacherState) -> str:\nreturn state.get(\"next_node\") or \"teaching_node\"\n\ngraph = StateGraph(TeacherState)\n\ngraph.add_node(\"onboarding_node\", onboarding_node) graph.add_node(\"curriculum_planning_node\", curriculum_planning_node) graph.add_node(\"teaching_node\", teaching_node) graph.add_node(\"student_input_node\", student_input_node) graph.add_node(\"understanding_analysis_node\", understanding_analysis_node) graph.add_node(\"pedagogical_decision_node\", pedagogical_decision_node) graph.add_node(\"transition_node\", transition_node) graph.add_node(\"remediation_node\", remediation_node)",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 20,
      "text": "graph.add_node(\"memory_update_node\", memory_update_node) graph.add_node(\"completion_node\", completion_node)\n\ngraph.set_entry_point(\"onboarding_node\")\n\ngraph.add_conditional_edges( \"onboarding_node\", _route_after_onboarding, { \"student_input_node\": \"student_input_node\", \"curriculum_planning_node\": \"curriculum_planning_node\", }, )\n\ngraph.add_edge(\"curriculum_planning_node\", \"pedagogical_decision_node\") graph.add_edge(\"pedagogical_decision_node\", \"transition_node\")\n\ngraph.add_conditional_edges( \"transition_node\", _route_after_transition, { \"teaching_node\": \"teaching_node\", \"remediation_node\": \"remediation_node\", \"completion_node\": \"completion_node\", }, )\n\ngraph.add_edge(\"teaching_node\", \"memory_update_node\") graph.add_edge(\"remediation_node\", \"memory_update_node\") graph.add_edge(\"memory_update_node\", \"student_input_node\")\n\ngraph.add_conditional_edges( \"student_input_node\", _route_after_student_input, { \"onboarding_node\": \"onboarding_node\", \"understanding_analysis_node\": \"understanding_analysis_node\", }, )\n\ngraph.add_edge(\"understanding_analysis_node\", \"pedagogical_decision_node\")",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    },
    {
      "page_number": 21,
      "text": "graph.add_edge(\"completion_node\", END)\n\nteacher_graph = graph.compile(checkpointer=MemorySaver(), interrupt_before=[\"student_input_node\"])",
      "metadata": {
        "has_images": false,
        "image_count": 0,
        "image_ids": [],
        "has_tables": false,
        "ocr_processed": false
      }
    }
  ],
  "metadata": {
    "source": "upload",
    "file_type": "pdf",
    "created_at": "2026-01-26T21:50:25.265649",
    "original_filename": "ai_teacher.pdf",
    "file_size": 526414
  },
  "processing_stats": {
    "page_count": 21,
    "total_text_length": "Classroom_control_agent :\nfrom mentor_ai.core.state import TeacherState\n\nclass ClassroomControlAgent:\n@staticmethod def build_redirect_message(state: TeacherState) -> str:\nsteps = state[\"lesson_steps\"] step = steps[state[\"current_step_index\"]] if steps else None objective = step[\"objective\"] if step else \"the current objective\" return ( \"Stay focused.\\n\" f\"We are working on: {objective}.\\n\" \"Answer the check question or ask a question about this step.\" )\n\nfrom typing import List\n\nfrom mentor_ai.core.state import Curriculum, LessonStep\n\nclass CurriculumAgent:\n@staticmethod def build_steps(curriculum: Curriculum) -> List[LessonStep]:\nchapter = curriculum[\"chapter\"].strip().lower() lesson = curriculum[\"lesson\"].strip().lower()\n\nif chapter == \"mathematics\" and lesson == \"fractions\":\nreturn [ { \"step_id\": 0, \"objective\": \"Explain what a fraction represents as parts of a whole\", \"strategy_pool\": [\"concrete_example\", \"visual\", \"analogy\", \"step_by_step\"], \"check_type\": \"question\", }, { \"step_id\": 1, \"objective\": \"Define numerator as how many parts are taken\", \"strategy_pool\": [\"visual\", \"step_by_step\", \"concrete_example\", \"analogy\"],\n\n\"check_type\": \"question\", }, { \"step_id\": 2, \"objective\": \"Define denominator as how many equal parts make the whole\", \"strategy_pool\": [\"visual\", \"concrete_example\", \"step_by_step\", \"analogy\"], \"check_type\": \"question\", }, { \"step_id\": 3, \"objective\": \"Identify numerator and denominator in simple fractions like 3/5\", \"strategy_pool\": [\"step_by_step\", \"visual\", \"concrete_example\"], \"check_type\": \"exercise\", }, { \"step_id\": 4, \"objective\": \"Interpret a fraction as 'numerator out of denominator' parts\", \"strategy_pool\": [\"analogy\", \"step_by_step\", \"concrete_example\", \"visual\"], \"check_type\": \"explanation_request\", }, ]\n\nreturn [ { \"step_id\": 0, \"objective\": f\"Define the core idea of {curriculum['lesson']}\", \"strategy_pool\": [\"step_by_step\", \"concrete_example\", \"visual\", \"analogy\"], \"check_type\": \"question\", }, { \"step_id\": 1, \"objective\": \"Practice identifying the key parts of the concept\", \"strategy_pool\": [\"step_by_step\", \"concrete_example\", \"visual\"], \"check_type\": \"exercise\", },\n\n]\n\nfrom typing import Any, Dict\n\nfrom mentor_ai.core.state import TeacherState\n\nclass MemoryAgent:\n@staticmethod def update(state: TeacherState) -> TeacherState:\nanalysis = state.get(\"last_analysis\") decision = state.get(\"last_decision\") steps = state[\"lesson_steps\"] if not steps:\nreturn state\n\nanalysis_step_id = None if isinstance(analysis, dict):\nanalysis_step_id = analysis.get(\"step_id\") step = next((s for s in steps if s[\"step_id\"] == analysis_step_id), None) if analysis_step_id is not None else None if step is None:\nstep = steps[state[\"current_step_index\"]] memory = state[\"memory\"]\n\nif decision:\nmemory[\"last_strategy_by_step\"][step[\"step_id\"]] = str(decision.get(\"strategy\") or \"\") memory[\"last_action_by_step\"][step[\"step_id\"]] = str(decision.get(\"action\") or \"\")\n\nif not analysis:\nstate[\"pedagogy\"][\"mastery_level\"] = MemoryAgent._compute_overall_mastery(state) return state\n\nemotion = str(analysis.get(\"emotion\") or \"neutral\").lower() memory[\"emotional_patterns\"][emotion] = memory[\"emotional_patterns\"].get(emotion, 0) + 1\n\nconfusion_type = str(analysis.get(\"confusion_type\") or \"none\").lower() if confusion_type != \"none\":\nmemory[\"confusion_patterns\"][confusion_type] = memory[\"confusion_patterns\"].get(confusion_type, 0) + 1\n\nunderstanding = str(analysis.get(\"understanding_level\") or \"none\").lower() current = memory[\"step_mastery\"].get(step[\"step_id\"], 0)\n\nif understanding == \"strong\":\nupdated = min(100, current + 40) elif understanding == \"good\":\nupdated = min(100, current + 25) elif understanding == \"partial\":\nupdated = max(0, current - 5) memory[\"failed_steps\"][step[\"step_id\"]] = memory[\"failed_steps\"].get(step[\"step_id\"], 0) + 1 else:\nupdated = max(0, current - 10) memory[\"failed_steps\"][step[\"step_id\"]] = memory[\"failed_steps\"].get(step[\"step_id\"], 0) + 1\n\nmemory[\"step_mastery\"][step[\"step_id\"]] = updated\n\nthreshold = state[\"pedagogy\"][\"mastery_threshold\"] if updated >= threshold and step[\"step_id\"] not in memory[\"success_steps\"]:\nmemory[\"success_steps\"].append(step[\"step_id\"])\n\nstrategy = str((decision or {}).get(\"strategy\") or \"\").strip() if strategy and updated >= threshold and strategy not in memory[\"preferred_strategies\"]:\nmemory[\"preferred_strategies\"].append(strategy)\n\nstate[\"pedagogy\"][\"mastery_level\"] = MemoryAgent._compute_overall_mastery(state) return state\n\n@staticmethod def _compute_overall_mastery(state: TeacherState) -> int:\nsteps = state[\"lesson_steps\"] mastery = state[\"memory\"][\"step_mastery\"] if not steps:\n\nreturn 0 values = [mastery.get(s[\"step_id\"], 0) for s in steps] return int(sum(values) / len(values))\n\nfrom typing import Any, Dict, Optional\n\nfrom mentor_ai.core.enums import DirectorAction, UnderstandingLevel from mentor_ai.core.state import TeacherState\n\nclass PedagogicalDirectorAgent:\n@staticmethod def decide(state: TeacherState) -> Dict[str, Any]:\nsteps = state[\"lesson_steps\"] step_index = state[\"current_step_index\"] analysis = state.get(\"last_analysis\") memory = state[\"memory\"]\n\nif not steps:\nreturn { \"action\": DirectorAction.EXPLAIN.value, \"target_step_index\": 0, \"strategy\": \"step_by_step\", \"check_type\": \"question\", \"reason\": \"No lesson steps loaded yet.\", }\n\nstep = steps[min(step_index, len(steps) - 1)] target_step_index = min(step_index, len(steps) - 1) step_mastery = memory[\"step_mastery\"].get(step[\"step_id\"], 0) threshold = state[\"pedagogy\"][\"mastery_threshold\"] last_strategy = memory[\"last_strategy_by_step\"].get(step[\"step_id\"])\n\nif analysis is None:\nstrategy = PedagogicalDirectorAgent._pick_strategy(step, last_strategy=last_strategy) return { \"action\": DirectorAction.EXPLAIN.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"],\n\n\"reason\": \"Start teaching the current step.\", }\n\nif analysis.get(\"off_topic\") is True:\nreturn { \"action\": DirectorAction.CONTROL.value, \"target_step_index\": target_step_index, \"strategy\": \"authority_redirect\", \"check_type\": \"question\", \"reason\": \"Student is off-topic; redirect to the current objective.\", }\n\nunderstanding = str(analysis.get(\"understanding_level\") or UnderstandingLevel.NONE.value).lower() failed_count = memory[\"failed_steps\"].get(step[\"step_id\"], 0) strategy = PedagogicalDirectorAgent._pick_strategy(step, last_strategy=last_strategy, failed_count=failed_count)\n\nif understanding in (UnderstandingLevel.GOOD.value, UnderstandingLevel.STRONG.value):\nif step_mastery >= threshold and understanding == UnderstandingLevel.STRONG.value:\nif step_index >= len(steps) - 1:\nreturn { \"action\": DirectorAction.COMPLETE.value, \"target_step_index\": target_step_index, \"strategy\": \"summary\", \"check_type\": \"question\", \"reason\": \"Final step mastered; complete the lesson.\", } return { \"action\": DirectorAction.MOVE_ON.value, \"target_step_index\": target_step_index + 1, \"strategy\": \"progression\", \"check_type\": steps[target_step_index + 1][\"check_type\"], \"reason\": \"Current step mastered; move to the next step.\", }\n\nreturn { \"action\": DirectorAction.ASK_QUESTION.value, \"target_step_index\": target_step_index,\n\n\"strategy\": \"checking\", \"check_type\": step[\"check_type\"], \"reason\": \"Understanding looks good; verify mastery with a focused check.\", }\n\nif understanding == UnderstandingLevel.PARTIAL.value:\nif failed_count >= 1:\nreturn { \"action\": DirectorAction.REMEDIATE.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"Partial understanding with prior failure; remediate using a different representation.\", } return { \"action\": DirectorAction.REPHRASE.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"Partial understanding; rephrase using a different strategy.\", }\n\nif failed_count >= 1:\nreturn { \"action\": DirectorAction.REMEDIATE.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"No understanding with prior failure; apply remediation.\", }\n\nreturn { \"action\": DirectorAction.EXPLAIN.value, \"target_step_index\": target_step_index, \"strategy\": strategy, \"check_type\": step[\"check_type\"], \"reason\": \"No understanding; explain again with a different strategy.\",\n\n}\n\n@staticmethod def _pick_strategy(step: Dict[str, Any], *, last_strategy: Optional[str], failed_count: int = 0) -> str:\npool = list(step.get(\"strategy_pool\") or []) if not pool:\nreturn \"step_by_step\"\n\nif last_strategy and last_strategy in pool:\npool = [s for s in pool if s != last_strategy] or [last_strategy]\n\nif failed_count >= 2:\nif \"concrete_example\" in pool:\nreturn \"concrete_example\" if \"visual\" in pool:\nreturn \"visual\"\n\nreturn pool[0]\n\nimport json from typing import Any, Dict\n\nfrom mentor_ai.core.state import TeacherState from mentor_ai.services.llm_service import LLMService\n\nclass StudentUnderstandingAgent:\n@staticmethod def analyze(state: TeacherState) -> Dict[str, Any]:\nstudent_input = (state.get(\"last_student_input\") or \"\").strip() step = state[\"lesson_steps\"][state[\"current_step_index\"]] if state[\"lesson_steps\"] else None\n\nsystem = ( \"You are StudentUnderstandingAgent.\\n\" \"You analyze the student's input for understanding.\\n\" \"You do not teach.\\n\" \"You do not decide pedagogy.\\n\" \"Return strict JSON only.\\n\\n\"\n\n\"Output JSON schema:\\n\" \"{\\n\" ' \"understanding_level\": \"none|partial|good|strong\",\\n' ' \"confusion_type\": \"conceptual|procedural|vocabulary|none\",\\n' ' \"emotion\": \"frustrated|confident|neutral|bored\",\\n' ' \"off_topic\": true|false,\\n' ' \"guessing\": true|false,\\n' ' \"hesitation\": true|false,\\n' ' \"notes\": \"string\"\\n' \"}\\n\" )\n\ncontext = { \"chapter\": state[\"curriculum\"][\"chapter\"], \"lesson\": state[\"curriculum\"][\"lesson\"], \"competence\": state[\"curriculum\"][\"competence\"], \"current_step_index\": state[\"current_step_index\"], \"current_step_objective\": step[\"objective\"] if step else None, \"student_input\": student_input, }\n\nuser = \"Analyze the student input.\\n\\nContext:\\n\" + json.dumps(context) content = LLMService.chat( [ {\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\": user}, ], temperature=0.0, json_mode=True, ) result = json.loads(content) if step is not None:\nresult[\"step_id\"] = step[\"step_id\"] result[\"step_index\"] = state[\"current_step_index\"] return result\n\nimport json from typing import Any, Dict\n\nfrom mentor_ai.core.state import TeacherState\n\nfrom mentor_ai.services.llm_service import LLMService\n\nclass TeacherAgent:\n@staticmethod def speak(state: TeacherState) -> str:\ndecision = state.get(\"last_decision\") or {} steps = state[\"lesson_steps\"] step = steps[state[\"current_step_index\"]] if steps else None\n\nexecute = decision.get(\"execute\") or {} teacher_action = execute.get(\"teacher_action\") or decision.get(\"action\") teacher_strategy = execute.get(\"teacher_strategy\") or decision.get(\"strategy\") check_type = execute.get(\"check_type\") or decision.get(\"check_type\")\n\ndirective: Dict[str, Any] = { \"action\": teacher_action, \"strategy\": teacher_strategy, \"check_type\": check_type, \"objective\": step[\"objective\"] if step else None, \"student_name\": state[\"student\"].get(\"name\"), \"student_mood\": state[\"student\"].get(\"mood\"), \"learning_style\": state[\"student\"].get(\"learning_style\"), \"mastery_level\": state[\"pedagogy\"][\"mastery_level\"], \"step_index\": state[\"current_step_index\"], }\n\nsystem = ( \"You are TeacherAgent.\\n\" \"You are the voice only.\\n\" \"You do not decide pedagogy.\\n\" \"You follow the directive.\\n\" \"No free conversation.\\n\" \"No small talk.\\n\" \"Do not invent new goals.\\n\" \"Prioritize teaching rituals: framing, pacing, reassurance, and progression.\\n\" )\n\nuser = ( \"Generate the teacher message for the student.\\n\"\n\n\"Constraints:\\n\" \"- One objective at a time.\\n\" \"- If action is ASK_QUESTION or TEST, end with a single clear prompt.\\n\" \"- If action is EXPLAIN or REPHRASE, explain and then ask a focused check.\\n\" \"- Avoid repeated metaphors.\\n\" \"- Keep authority and clarity.\\n\\n\" \"Directive:\\n\" + json.dumps(directive) )\n\nreturn LLMService.chat( [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\":\nuser}], temperature=0.4, json_mode=False, )\n\n@staticmethod def remediate(state: TeacherState) -> str:\ndecision = state.get(\"last_decision\") or {} steps = state[\"lesson_steps\"] step = steps[state[\"current_step_index\"]] if steps else None analysis = state.get(\"last_analysis\") or {}\n\nexecute = decision.get(\"execute\") or {} teacher_strategy = execute.get(\"teacher_strategy\") or decision.get(\"strategy\")\n\ndirective: Dict[str, Any] = { \"action\": \"REMEDIATE\", \"strategy\": teacher_strategy, \"objective\": step[\"objective\"] if step else None, \"confusion_type\": analysis.get(\"confusion_type\"), \"emotion\": analysis.get(\"emotion\"), \"step_index\": state[\"current_step_index\"], }\n\nsystem = ( \"You are TeacherAgent.\\n\" \"You are executing a remediation intervention.\\n\"\n\n\"No free conversation.\\n\" \"No generic praise.\\n\" \"Use pacing and reassurance.\\n\" \"Change representation.\\n\" \"Keep it short and targeted.\\n\" )\n\nuser = \"Generate the remediation message.\\n\\nDirective:\\n\" + json.dumps(directive) return LLMService.chat( [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\":\nuser}], temperature=0.3, json_mode=False, )\n\n@staticmethod def complete(state: TeacherState) -> str:\nsystem = ( \"You are TeacherAgent.\\n\" \"You close the lesson like a real teacher.\\n\" \"No small talk.\\n\" \"Summarize what was mastered.\\n\" \"Give one short next step.\\n\" ) user = ( \"Close the lesson.\\n\\nState summary:\\n\" + json.dumps( { \"chapter\": state[\"curriculum\"][\"chapter\"], \"lesson\": state[\"curriculum\"][\"lesson\"], \"competence\": state[\"curriculum\"][\"competence\"], \"mastery_level\": state[\"pedagogy\"][\"mastery_level\"], \"success_steps\": state[\"memory\"][\"success_steps\"], } ) ) return LLMService.chat( [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\":\nuser}], temperature=0.4, json_mode=False,\n\n)\n\nfrom mentor_ai.agents.teacher_agent import TeacherAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef completion_node(state: TeacherState) -> TeacherState:\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.COMPLETED state[\"last_teacher_output\"] = TeacherAgent.complete(state) return state\n\nfrom mentor_ai.agents.curriculum_agent import CurriculumAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef curriculum_planning_node(state: TeacherState) -> TeacherState:\nsteps = CurriculumAgent.build_steps(state[\"curriculum\"]) state[\"lesson_steps\"] = steps state[\"current_step_index\"] = 0 state[\"last_analysis\"] = None state[\"last_decision\"] = None state[\"next_node\"] = None state[\"pedagogy\"][\"current_mode\"] = TeacherMode.TEACHING return state\n\nfrom mentor_ai.agents.memory_agent import MemoryAgent from mentor_ai.core.state import TeacherState\n\ndef memory_update_node(state: TeacherState) -> TeacherState:\nreturn MemoryAgent.update(state)\n\nfrom mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef onboarding_node(state: TeacherState) -> TeacherState:\nstudent = state[\"student\"] onboarding = state[\"onboarding\"] last_input = (state.get(\"last_student_input\") or \"\").strip()\n\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.ONBOARDING\n\nif onboarding[\"complete\"] is True:\nstate[\"last_teacher_output\"] = None return state\n\nstage = onboarding[\"stage\"]\n\nif stage == \"name\":\nif last_input:\nstudent[\"name\"] = last_input[:60] onboarding[\"stage\"] = \"mood\" state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"Before we start, tell me your name.\" return state\n\nif stage == \"mood\":\nif last_input:\nmood = last_input.lower() if \"frustr\" in mood:\nstudent[\"mood\"] = \"frustrated\" elif \"bored\" in mood:\nstudent[\"mood\"] = \"bored\" elif \"confident\" in mood:\nstudent[\"mood\"] = \"confident\" else:\nstudent[\"mood\"] = \"neutral\" onboarding[\"stage\"] = \"ready\" state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"How are you feeling about this topic right now: confident, neutral, frustrated, or bored?\" return state\n\nif stage == \"ready\":\nif last_input:\nnormalized = last_input.lower() if any(k in normalized for k in [\"yes\", \"ready\", \"ok\", \"okay\", \"sure\", \"let's\", \"lets\", \"start\"]):\nonboarding[\"complete\"] = True onboarding[\"stage\"] = \"done\" state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"Good. We will start now. One step at a time.\" return state state[\"last_student_input\"] = None state[\"last_teacher_output\"] = \"Are you ready to start the lesson? Answer yes or no.\" return state\n\nonboarding[\"stage\"] = \"name\" state[\"last_teacher_output\"] = \"Before we start, tell me your name.\" return state\n\nfrom mentor_ai.agents.pedagogical_director_agent import PedagogicalDirectorAgent from mentor_ai.core.state import TeacherState\n\ndef pedagogical_decision_node(state: TeacherState) -> TeacherState:\nstate[\"last_decision\"] = PedagogicalDirectorAgent.decide(state) return state\n\nfrom mentor_ai.agents.teacher_agent import TeacherAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef remediation_node(state: TeacherState) -> TeacherState:\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.REMEDIATION state[\"last_teacher_output\"] = TeacherAgent.remediate(state) return state\n\nfrom mentor_ai.core.state import TeacherState\n\ndef student_input_node(state: TeacherState) -> TeacherState:\nreturn state\n\nfrom mentor_ai.agents.classroom_control_agent import ClassroomControlAgent from mentor_ai.agents.teacher_agent import TeacherAgent from mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState\n\ndef teaching_node(state: TeacherState) -> TeacherState:\nstate[\"pedagogy\"][\"current_mode\"] = TeacherMode.TEACHING decision = state.get(\"last_decision\") or {} execute = decision.get(\"execute\") or {} teacher_action = execute.get(\"teacher_action\") or decision.get(\"action\")\n\nif teacher_action == \"CONTROL\":\nstate[\"last_teacher_output\"] = ClassroomControlAgent.build_redirect_message(state) return state\n\nstate[\"last_teacher_output\"] = TeacherAgent.speak(state) return state\n\nfrom mentor_ai.core.enums import DirectorAction from mentor_ai.core.state import TeacherState\n\ndef transition_node(state: TeacherState) -> TeacherState:\ndecision = state.get(\"last_decision\") or {} action = str(decision.get(\"action\") or \"\") steps = state[\"lesson_steps\"]\n\nif action == DirectorAction.COMPLETE.value:\ndecision[\"execute\"] = { \"node\": \"completion_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"COMPLETE\", \"teacher_strategy\": \"summary\", \"check_type\": \"question\", } state[\"next_node\"] = \"completion_node\" state[\"last_decision\"] = decision return state\n\nif action == DirectorAction.REMEDIATE.value:\ndecision[\"execute\"] = { \"node\": \"remediation_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"REMEDIATE\", \"teacher_strategy\": decision.get(\"strategy\"), \"check_type\": decision.get(\"check_type\"), } state[\"next_node\"] = \"remediation_node\" state[\"last_decision\"] = decision return state\n\nif action == DirectorAction.MOVE_ON.value:\ntarget = decision.get(\"target_step_index\") if isinstance(target, int):\nstate[\"current_step_index\"] = max(0, min(target, max(0, len(steps) - 1))) state[\"last_analysis\"] = None next_step = steps[state[\"current_step_index\"]] if steps else None strategy_pool = (next_step or {}).get(\"strategy_pool\") or [\"step_by_step\"] decision[\"execute\"] = { \"node\": \"teaching_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"EXPLAIN\", \"teacher_strategy\": strategy_pool[0], \"check_type\": (next_step or {}).get(\"check_type\") or \"question\", } state[\"next_node\"] = \"teaching_node\" state[\"last_decision\"] = decision\n\nreturn state\n\nif action == DirectorAction.CONTROL.value:\ndecision[\"execute\"] = { \"node\": \"teaching_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": \"CONTROL\", \"teacher_strategy\": \"authority_redirect\", \"check_type\": \"question\", } state[\"next_node\"] = \"teaching_node\" state[\"last_decision\"] = decision return state\n\ndecision[\"execute\"] = { \"node\": \"teaching_node\", \"step_index\": state[\"current_step_index\"], \"teacher_action\": action, \"teacher_strategy\": decision.get(\"strategy\"), \"check_type\": decision.get(\"check_type\"), } state[\"next_node\"] = \"teaching_node\" state[\"last_decision\"] = decision return state\n\nfrom mentor_ai.agents.student_understanding_agent import StudentUnderstandingAgent from mentor_ai.core.state import TeacherState\n\ndef understanding_analysis_node(state: TeacherState) -> TeacherState:\nstate[\"last_analysis\"] = StudentUnderstandingAgent.analyze(state) return state\n\nfrom langgraph.checkpoint.memory import MemorySaver from langgraph.graph import END, StateGraph\n\nfrom mentor_ai.core.enums import TeacherMode from mentor_ai.core.state import TeacherState from mentor_ai.graph.nodes.completion_node import completion_node from mentor_ai.graph.nodes.curriculum_planning_node import curriculum_planning_node from mentor_ai.graph.nodes.memory_update_node import memory_update_node from mentor_ai.graph.nodes.onboarding_node import onboarding_node from mentor_ai.graph.nodes.pedagogical_decision_node import pedagogical_decision_node from mentor_ai.graph.nodes.remediation_node import remediation_node from mentor_ai.graph.nodes.student_input_node import student_input_node from mentor_ai.graph.nodes.teaching_node import teaching_node from mentor_ai.graph.nodes.transition_node import transition_node from mentor_ai.graph.nodes.understanding_analysis_node import understanding_analysis_node\n\ndef _route_after_student_input(state: TeacherState) -> str:\nif state[\"pedagogy\"][\"current_mode\"] == TeacherMode.ONBOARDING:\nreturn \"onboarding_node\" return \"understanding_analysis_node\"\n\ndef _route_after_onboarding(state: TeacherState) -> str:\nif state[\"onboarding\"][\"complete\"] is True:\nreturn \"curriculum_planning_node\" return \"student_input_node\"\n\ndef _route_after_transition(state: TeacherState) -> str:\nreturn state.get(\"next_node\") or \"teaching_node\"\n\ngraph = StateGraph(TeacherState)\n\ngraph.add_node(\"onboarding_node\", onboarding_node) graph.add_node(\"curriculum_planning_node\", curriculum_planning_node) graph.add_node(\"teaching_node\", teaching_node) graph.add_node(\"student_input_node\", student_input_node) graph.add_node(\"understanding_analysis_node\", understanding_analysis_node) graph.add_node(\"pedagogical_decision_node\", pedagogical_decision_node) graph.add_node(\"transition_node\", transition_node) graph.add_node(\"remediation_node\", remediation_node)\n\ngraph.add_node(\"memory_update_node\", memory_update_node) graph.add_node(\"completion_node\", completion_node)\n\ngraph.set_entry_point(\"onboarding_node\")\n\ngraph.add_conditional_edges( \"onboarding_node\", _route_after_onboarding, { \"student_input_node\": \"student_input_node\", \"curriculum_planning_node\": \"curriculum_planning_node\", }, )\n\ngraph.add_edge(\"curriculum_planning_node\", \"pedagogical_decision_node\") graph.add_edge(\"pedagogical_decision_node\", \"transition_node\")\n\ngraph.add_conditional_edges( \"transition_node\", _route_after_transition, { \"teaching_node\": \"teaching_node\", \"remediation_node\": \"remediation_node\", \"completion_node\": \"completion_node\", }, )\n\ngraph.add_edge(\"teaching_node\", \"memory_update_node\") graph.add_edge(\"remediation_node\", \"memory_update_node\") graph.add_edge(\"memory_update_node\", \"student_input_node\")\n\ngraph.add_conditional_edges( \"student_input_node\", _route_after_student_input, { \"onboarding_node\": \"onboarding_node\", \"understanding_analysis_node\": \"understanding_analysis_node\", }, )\n\ngraph.add_edge(\"understanding_analysis_node\", \"pedagogical_decision_node\")\n\ngraph.add_edge(\"completion_node\", END)\n\nteacher_graph = graph.compile(checkpointer=MemorySaver(), interrupt_before=[\"student_input_node\"])",
    "tables_count": 0,
    "images_count": 0
  },
  "warnings": [],
  "errors": []
}